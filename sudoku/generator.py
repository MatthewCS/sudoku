from datetime import datetime


def initial_variables(board):

    # The key name for each var is v<VALUE>_<COLUMN>x<ROW>
    vars = dict()
    size = len(board)

    # Check rows
    for i in range(0, size):

        row = board[i]
        # Get the values in a row
        for j in range(0, size):

            # Set everything for this cell to false
            for n in range(1, size + 1):

                v_name = "v{0}_{1}x{2}".format(n, j + 1, i + 1)
                vars[v_name] = False

            # If this cell contains a value, then make it that value true.
            if board[i][j] != "":
                v_name = "v{0}_{1}x{2}".format(board[i][j], j + 1, i + 1)
                vars[v_name] = True

    return vars


def get_code(board):

    timestamp = datetime.now().strftime("%m/%d/%Y, %H:%M:%S")
    code = "; Code generated by a Python script on {0}\n\n".format(timestamp)
    variables = initial_variables(board)
    var_str = "v{0}_{1}x{2}"


    code += "; Variable naming scheme: <VALUE>_<COLUMN>x<ROW>\n"
    code += "; Declare values:\n"
    for key in variables:
        code += "(declare-const {0} Bool)\n".format(key)
    code += "\n"


    code += "; Known cell values\n"
    for key, value in variables.items():
        if value:
            code += "(assert (= {0} true))\n".format(key)
    code += "\n"


    code += "; Logic\n"
    code += "; Using xor statements --- one column can have one value,\n"
    code += ";   one row can have one value, and one cell can have one\n"
    code += ";   value.\n"
    code += "\n"

    code += "; A cell can only hold one value.\n"
    code += "; \n"
    code += "; Here, we tell z3 to only hold one value in a cell\n"
    code += "; and that a cell must hold one value.\n"
    code += "\n"
    for i in range(1, len(board) + 1):

        for j in range(1, len(board) + 1):

            this_cell_vals = []

            for cell_value in range(1, len(board) + 1):

                this_cell_vals.append(var_str.format(cell_value, i, j))

            code += "; Values for cell {0} x {1}\n".format(i, j)

            for k in range(0, len(this_cell_vals)):
                # values before and after value k in this_cell_vals
                other_vars = this_cell_vals[:k] + this_cell_vals[(k+1):]
                code += "(assert\n"
                code += "  (=> (= {0} true)\n".format(this_cell_vals[k])
                code += "    (and\n"
                for var in other_vars:
                    code += "      (= {0} false)\n".format(var)
                code += "    )\n"
                code += "  )\n"
                code += ")\n"

            code += "(assert\n"
            code += "  (xor\n"
            code += "    {0}\n".format(" ".join(this_cell_vals))
            code += "  )\n"
            code += ")\n"
            code += "\n"
    code += "\n"


    code += "; Here, we tell z3 that each row and each column\n"
    code += "; must have only one instance of each value.\n"
    code += "\n"
    for cell_value in range(1, len(board) + 1):

        for i in range(1, len(board) + 1):

            this_val_rows = []
            this_val_cols = []

            for j in range(1, len(board) + 1):

                this_val_rows.append(var_str.format(cell_value, i, j))
                this_val_cols.append(var_str.format(cell_value, j, i))

            code += "; Row {0}\n".format(i)
            code += "(assert \n"
            code += "  (xor\n"
            code += "    {0}\n".format(" ".join(this_val_rows))
            code += "  )\n"
            code += ")\n"
            code += "; Column {0}\n".format(i)
            code += "(assert \n"
            code += "  (xor\n"
            code += "    {0}\n".format(" ".join(this_val_cols))
            code += "  )\n"
            code += ")\n"

            code += "; Rows, columns only have one instance of value {0}\n".format(cell_value)
            for k in range(0, len(board)):
                # values before and after value k in this_cell_vals
                other_rows = this_val_rows[:k] + this_val_rows[(k+1):]
                other_cols = this_val_cols[:k] + this_val_cols[(k+1):]
                code += "; Rows for {0}\n".format(this_val_rows[k])
                code += "(assert\n"
                code += "  (=> (= {0} true)\n".format(this_val_rows[k])
                code += "    (and\n"
                for row in other_rows:
                    code += "      (= {0} false)\n".format(row)
                code += "    )\n"
                code += "  )\n"
                code += ")\n"
                code += "; Columns for {0}\n".format(this_val_cols[k])
                code += "(assert\n"
                code += "  (=> (= {0} true)\n".format(this_val_cols[k])
                code += "    (and\n"
                for col in other_cols:
                    code += "      (= {0} false)\n".format(col)
                code += "    )\n"
                code += "  )\n"
                code += ")\n"
                code += "\n"

    code += "\n"



    code += "; Check if the sudoku board is possible to solve, and\n"
    code += "; give the solution as a z3 model.\n"
    code += "(check-sat)\n"
    code += "(get-model)\n"

    return code
