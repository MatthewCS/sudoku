from datetime import datetime
from math import sqrt


def initial_variables(board):

    # The key name for each var is v<VALUE>_<COLUMN>x<ROW>
    var_str = "v{0}_{1}x{2}"
    vars = dict()
    size = len(board)

    # Check rows
    for i in range(0, size):

        row = board[i]
        # Get the values in a row
        for j in range(0, size):

            # Set everything for this cell to false
            for n in range(1, size + 1):

                v_name = var_str.format(n, j + 1, i + 1)
                vars[v_name] = False

            # If this cell contains a value, then make it that value true.
            if board[i][j] != "":
                v_name = var_str.format(board[i][j], j + 1, i + 1)
                vars[v_name] = True

    return vars


def get_code(board):

    timestamp = datetime.now().strftime("%m/%d/%Y, %H:%M:%S")
    code = "; Code generated by a Python script on {0}\n\n".format(timestamp)
    variables = initial_variables(board)
    var_str = "v{0}_{1}x{2}"
    board_size = len(board)


    code += "; Variable naming scheme: <VALUE>_<COLUMN>x<ROW>\n"
    code += "; Declare values:\n"
    for key in variables:
        code += "(declare-const {0} Bool)\n".format(key)
    code += "\n"


    code += "; Known cell values\n"
    for key, value in variables.items():
        if value:
            code += "(assert (= {0} true))\n".format(key)
    code += "\n"


    code += "; Logic\n"
    code += "; Using xor statements --- one column can have one value,\n"
    code += ";   one row can have one value, and one cell can have one\n"
    code += ";   value.\n"
    code += "\n"

    code += "; A cell can only hold one value.\n"
    code += "; \n"
    code += "; Here, we tell z3 to only hold one value in a cell\n"
    code += "; and that a cell must hold one value.\n"
    code += "\n"
    for i in range(1, board_size + 1):

        for j in range(1, board_size + 1):

            this_cell_vals = []

            for cell_value in range(1, board_size + 1):

                this_cell_vals.append(var_str.format(cell_value, i, j))

            code += "; Values for cell {0} x {1}\n".format(i, j)

            for k in range(0, len(this_cell_vals)):
                # values before and after value k in this_cell_vals
                other_vars = this_cell_vals[:k] + this_cell_vals[(k+1):]
                code += "(assert\n"
                code += "  (=> (= {0} true)\n".format(this_cell_vals[k])
                code += "    (and\n"
                for var in other_vars:
                    code += "      (= {0} false)\n".format(var)
                code += "    )\n"
                code += "  )\n"
                code += ")\n"

            code += "(assert\n"
            code += "  (xor\n"
            code += "    {0}\n".format(" ".join(this_cell_vals))
            code += "  )\n"
            code += ")\n"
            code += "\n"
    code += "\n"


    code += "; Here, we tell z3 that each row and each column\n"
    code += "; must have only one instance of each value.\n"
    code += "\n"
    for cell_value in range(1, board_size + 1):

        for i in range(1, board_size + 1):

            this_val_rows = []
            this_val_cols = []

            for j in range(1, board_size + 1):

                this_val_rows.append(var_str.format(cell_value, i, j))
                this_val_cols.append(var_str.format(cell_value, j, i))

            code += "; Row {0}\n".format(i)
            code += "(assert \n"
            code += "  (xor\n"
            code += "    {0}\n".format(" ".join(this_val_rows))
            code += "  )\n"
            code += ")\n"
            code += "; Column {0}\n".format(i)
            code += "(assert \n"
            code += "  (xor\n"
            code += "    {0}\n".format(" ".join(this_val_cols))
            code += "  )\n"
            code += ")\n"

            code += "; Rows, columns only have one instance of value {0}\n".format(cell_value)
            for k in range(0, board_size):
                # values before and after value k in this_cell_vals
                other_rows = this_val_rows[:k] + this_val_rows[(k+1):]
                other_cols = this_val_cols[:k] + this_val_cols[(k+1):]
                code += "; Rows for {0}\n".format(this_val_rows[k])
                code += "(assert\n"
                code += "  (=> (= {0} true)\n".format(this_val_rows[k])
                code += "    (and\n"
                for row in other_rows:
                    code += "      (= {0} false)\n".format(row)
                code += "    )\n"
                code += "  )\n"
                code += ")\n"
                code += "; Columns for {0}\n".format(this_val_cols[k])
                code += "(assert\n"
                code += "  (=> (= {0} true)\n".format(this_val_cols[k])
                code += "    (and\n"
                for col in other_cols:
                    code += "      (= {0} false)\n".format(col)
                code += "    )\n"
                code += "  )\n"
                code += ")\n"
                code += "\n"

    code += "\n"


    code += "; We also need to tell z3 that, for a board of size\n"
    code += "; n^2 x n^2, we need to make subdivisions of n x n\n"
    code += "; squares where each possible value appears only once.\n"
    code += "\n"
    square_size = int(sqrt(board_size))
    # The first two loops create subdivisions of size n x n
    for i in range(1, board_size, square_size):
        col_bounds = i + square_size - 1
        for j in range(1, board_size, square_size):
            row_bounds = j + square_size - 1
            code += "; Subdivision from {0} x {1} to {2} x {3}\n".format(i, j, col_bounds, row_bounds)
            # Generate each position of our subdivision
            positions = []
            for col in range(i, col_bounds + 1):
                for row in range(j, row_bounds + 1):
                    positions.append((col, row))
            # If a value is in this position, it cannot be in any
            # other position in this subdivision
            for pos_index in range(0, len(positions)):
                other_positions = positions[:pos_index] + positions[(pos_index + 1):]
                code += "; Position {0[0]} x {0[1]}\n".format(positions[pos_index])
                for cell_value in range(1, board_size + 1):
                    code += "; Value {0}\n".format(cell_value)
                    code += "(assert\n"
                    code += "  (=> (= v{0}_{1[0]}x{1[1]} true)\n".format(cell_value, positions[pos_index])
                    code += "    (and\n"
                    for pos in other_positions:
                        code += "      (= v{0}_{1[0]}x{1[1]} false)\n".format(cell_value, pos)
                    code += "    )\n"
                    code += "  )\n"
                    code += ")\n"
            code += "\n"



    code += "; Check if the sudoku board is possible to solve, and\n"
    code += "; give the solution as a z3 model.\n"
    code += "(check-sat)\n"
    code += "(get-model)\n"

    return code
